**REAL FAKE NEWS**

To install Docker on Linux, I used the following tutorial:
https://linuxiac.com/how-to-install-docker-on-pop-os-22-04/

A well designed news site where the content is entirely generated by AI Large Language Models. 
The website is meant to look like a "real" news site, with articles in different sections, different authors, events, editors, and so on.
To allow the site to be interesting on its own as a parody site, the news items will be as fake as can be, and there will be an interactive elements
for the reader as well as backend interactions between the different "writers" and the "editor".

The tech stack will be MERN(MongoDB, Express, React, Node).
As of 22.10.25, MongoDB is not used, instead, I am using LowDB as it is a simpler approach and MongoDB is not currently needed, a possible move to SQLite is in order.

# Environment Configuration

All environment variables, config files, and constants used across the project are documented in **`ENV_CONFIG.example`** in the root directory.

This comprehensive file includes:
- **Environment Variables**: All `.env` variables for Server, Client, and Admin
- **Config Files**: Documentation of all configuration files and their purposes
- **Constants**: All hardcoded constants and where they're used

The file is organized by:
- **Server** (Node.js/Express backend) - `server/.env`
- **Client** (React frontend) - `client/.env`
- **Admin** (Svelte admin panel) - `admin/.env`

To set up the project:
1. Copy `ENV_CONFIG.example` and extract the relevant sections to create `.env` files in each subdirectory
2. Fill in your API keys (DeepSeek, NewsData.io, Runware)
3. Configure Gmail credentials if using email service
4. Set a secure `ADMIN_PASSWORD` (change from default!)

See `ENV_CONFIG.example` for complete documentation of all environment variables, config files, and constants.

# Running the Application

## Prerequisites

1. **Docker and Docker Compose** installed on your system
2. **Root `.env` file** created from `docker-compose.env.example`:
   ```bash
   cp docker-compose.env.example .env
   # Edit .env and fill in your API keys and paths
   ```
3. **Required directories** created (as specified in `.env`):
   ```bash
   mkdir -p /path/to/your/SQLITE_DATA_PATH
   mkdir -p /path/to/your/IMAGES_DATA_PATH
   ```

## Development Mode

**Use this for local development and testing.**

### Start Development Environment

```bash
docker compose -f docker-compose.yml -f docker-compose.dev.yml up --build
```

### Development Mode Features

- **Server**: Runs with `NODE_ENV=development`
- **Client**: Debug logs enabled (`VITE_DEBUG_LOGS=true`)
- **Admin**: Frontend dev mode enabled
- **Hot Reload**: Not enabled by default (see below for enabling)

### Development Commands

```bash
# Start in detached mode (background)
docker compose -f docker-compose.yml -f docker-compose.dev.yml up -d

# View logs
docker compose -f docker-compose.yml -f docker-compose.dev.yml logs -f

# Rebuild specific service
docker compose -f docker-compose.yml -f docker-compose.dev.yml build --no-cache client

# Stop services
docker compose -f docker-compose.yml -f docker-compose.dev.yml down

# Restart a service
docker compose -f docker-compose.yml -f docker-compose.dev.yml restart client
```

### Access Development Services

- **Client**: http://localhost:5173
- **Admin**: http://localhost:5174
- **Server API**: http://localhost:5001/api

---

## Hot-Reload Development (Without Docker)

For the fastest development experience with instant hot-reload, run the services directly on your host machine:

### Prerequisites

1. **Node.js 20+** and **npm** installed
2. **Environment variables** set up in each directory:
   ```bash
   # Copy example environment files
   cp server/.env.example server/.env
   cp client/.env.example client/.env
   cp admin/.env.example admin/.env
   
   # Edit each .env file with your configuration
   ```

### Running Services with Hot-Reload

#### Terminal 1: Backend Server
```bash
cd server
npm install
npm run dev
```
- **Port**: 5001
- **Hot-reload**: Uses nodemon to restart on TypeScript changes
- **Access**: http://localhost:5001/api/health

#### Terminal 2: React Client
```bash
cd client
npm install
npm run dev
```
- **Port**: 5173
- **Hot-reload**: Vite provides instant updates
- **Access**: http://localhost:5173

#### Terminal 3: Svelte Admin
```bash
cd admin
npm install
npm run dev
```
- **Port**: 5174
- **Hot-reload**: Vite provides instant updates
- **Access**: http://localhost:5174

### Hot-Reload Features

- **Instant Updates**: Code changes appear in the browser within milliseconds
- **State Preservation**: React/Svelte component state is preserved during updates
- **TypeScript Support**: Automatic compilation and error reporting
- **CSS Updates**: Styles update without page refresh

### Environment Configuration for Local Development

Update these environment variables for local development:

**In `client/.env`:**
```env
VITE_BACKEND_DEV_MODE=true
VITE_API_BASE_DEV=http://localhost:5001
VITE_USE_RELATIVE_API=false
VITE_DEBUG_LOGS=true
```

**In `admin/.env`:**
```env
VITE_BACKEND_DEV_MODE=true
VITE_API_BASE_DEV=http://localhost:5001
VITE_USE_RELATIVE_API=false
VITE_FRONTEND_DEV_MODE=true
VITE_CLIENT_URL_DEV=http://localhost:5173
```

**In `server/.env`:**
```env
NODE_ENV=development
DEBUG_LOGS=true
LOCAL_DEV_BACKEND=true
```

### Development Workflow

1. **Start all services** in separate terminals as shown above
2. **Make code changes** in any service
3. **See instant updates** in the browser
4. **Debug** using browser developer tools and server logs

### Advantages Over Docker Development

- **Faster**: No Docker build/rebuild time
- **Instant**: Changes appear immediately
- **Lighter**: Uses host resources directly
- **Debugging**: Easier to attach debuggers and profilers

### Switching Between Docker and Local Development

When switching from Docker to local development:

1. **Stop Docker containers**:
   ```bash
   docker compose -f docker-compose.yml -f docker-compose.dev.yml down
   ```

2. **Clear port bindings** (if needed):
   ```bash
   fuser -k 5173/tcp 5174/tcp 5001/tcp 2>/dev/null || echo "Ports freed"
   ```

3. **Start local services** as described above

---

## Production Mode

**Use this for production deployments.**

### Start Production Environment

```bash
docker compose up --build
```

### Production Mode Features

- **Server**: Runs with `NODE_ENV=production`
- **Client**: Debug logs disabled (`VITE_DEBUG_LOGS=false`)
- **Admin**: Frontend dev mode disabled
- **Optimized**: Production-optimized builds

### Production Commands

```bash
# Start in detached mode (background)
docker compose up -d

# View logs
docker compose logs -f

# Rebuild all services
docker compose build --no-cache

# Stop services
docker compose down

# Restart services
docker compose restart
```

### Access Production Services

- **Client**: http://localhost:5173 (or your configured port)
- **Admin**: http://localhost:5174 (or your configured port)
- **Server API**: http://localhost:5001/api (or your configured port)

---

## Key Differences

| Feature | Development Mode | Production Mode |
|---------|-----------------|-----------------|
| **Command** | `docker compose -f docker-compose.yml -f docker-compose.dev.yml up` | `docker compose up` |
| **NODE_ENV** | `development` | `production` |
| **Debug Logs** | Enabled | Disabled |
| **Error Messages** | Detailed | Generic |
| **Build Optimization** | Standard | Optimized |

## Common Tasks

### Rebuild After Code Changes

**Development:**
```bash
docker compose -f docker-compose.yml -f docker-compose.dev.yml build --no-cache client
docker compose -f docker-compose.yml -f docker-compose.dev.yml up -d client
```

**Production:**
```bash
docker compose build --no-cache client
docker compose up -d client
```

### View Service Logs

**Development:**
```bash
docker compose -f docker-compose.yml -f docker-compose.dev.yml logs -f server
docker compose -f docker-compose.yml -f docker-compose.dev.yml logs -f client
```

**Production:**
```bash
docker compose logs -f server
docker compose logs -f client
```

### Check Service Status

```bash
docker compose ps
# or for development:
docker compose -f docker-compose.yml -f docker-compose.dev.yml ps
```

### Stop All Services

**Development:**
```bash
docker compose -f docker-compose.yml -f docker-compose.dev.yml down
```

**Production:**
```bash
docker compose down
```

## Troubleshooting

### Services Won't Start

1. Check if ports are already in use:
   ```bash
   netstat -tulpn | grep -E "5001|5173|5174"
   ```

2. Verify `.env` file exists and has correct values:
   ```bash
   cat .env | grep -E "SQLITE_DATA_PATH|IMAGES_DATA_PATH"
   ```

3. Check Docker logs:
   ```bash
   docker compose logs
   ```

### Client Can't Connect to Server

1. Verify all containers are running:
   ```bash
   docker compose ps
   ```

2. Test server directly:
   ```bash
   curl http://localhost:5001/api/health
   ```

3. Test proxy:
   ```bash
   curl http://localhost:5173/api/health
   ```

4. Rebuild client with correct config:
   ```bash
   docker compose -f docker-compose.yml -f docker-compose.dev.yml build --no-cache client
   docker compose -f docker-compose.yml -f docker-compose.dev.yml up -d client
   ```

### Database Issues

- Ensure `SQLITE_DATA_PATH` directory exists and is writable
- Check database file permissions:
  ```bash
  ls -la /path/to/your/database.db
  ```

For more detailed troubleshooting, see:
- `DOCKER_ENV_SETUP.md` - Docker environment setup guide
- `CLIENT_CONNECTION_DEBUG.md` - Client-server connection debugging
- `DATABASE_LOCATION.md` - Database location configuration

# Design
## Front-end
An example website that I use as a model is: https://www.ynet.co.il, https://www.bbc.com/news 

The website will have the following elements:
- Logo -> A button to redirect to the home page
- Header -> Contains buttons to the various site sections
- Footer -> Will show information about the website creator and licensing information
- Article -> Will contain a timestamp of creation, an author name, and the content will be shown/saved in a markdown format.
- Home page -> At the top it will present the front-side article, then the other main articles, and then the other lesser sections and articles.

### Possible additions:
- [x] Carousel/News Ticker/Slideshow -> This will show the most recent events/articles in a shortened format and will act as buttons towards the related content.
- [ ] Simple weather description -> This will be a real weather element that will pull from real data sources to show the current weather in various places
- [ ] Local time clock
- [ ] Fake sponsors -> To be added to the footer
- [ ] Comments section in an article -> along with "totally not fake" bot comments
- [ ] Login option through Google or Facebook which allow to leave a comment
- [ ] RSS for articles
- [ ] Search button -> This will allow a user to search through the articles in the website according to key words 
- [ ] Automatically generated images in the middle of articles -> and also for banners for the articles
- [ ] A tip jar for the humble creator of said website
- [x] Dark/Light mode button
- [x] Pages for writers for all their articles to be displayed in the page
- [ ] Pagination where needed
- [ ] Games section, **In development** - A tic-tac-toe game and a Trivia game
- [ ] Share buttons on article: https://www.npmjs.com/package/react-share 
- [ ] Descriptions for images below them in articles, attribution.

## Back-end
The backend will need to have the following parts for the website to work:

1. A safe and cheap way of connecting to Large Language Models. We will use the OpenAI API in Node and DeepSeek(as it is quite cheap).
2. A complex state machine that takes all existing articles/writers into consideration and chooses the next operation in the website accordingly.
Writers will interact with other writers, discuss with the editors, and will form simple relationships and life histories of their own that will
effect their reporting.
3. MongoDB database that will save the articles, the writers and the state as described above. There is also a possibility of saving generated images too.
4. A service that connects to an open News API to take relevant daily information as part of the consideration to write relevant articles.

## Shared Parts:
There are several shared aspects between both the front-end and back-end. The main ones refer to the news categories that we're interested in, and the information in the articles that we want to add to a final JSON representation of these in our article database along with on the front-end website.

# Lessons learned:
- DON'T install npm and node through apt-get, instead, install nvm and use _THAT_ to install those properly: https://www.freecodecamp.org/news/node-version-manager-nvm-install-guide/ + https://docs.npmjs.com/downloading-and-installing-node-js-and-npm
- DON'T use "npx create-react-app" because it has constant issues, instead, use Vite: https://vite.dev/guide/ -> For the frontend "client", I used the command: "npm create vite@latest client -- --template react-ts"
- For the Node backend with TypeScript and Express I used the tutorial: https://medium.com/@vihangamallawaarachchi.dev/setting-up-a-node-js-and-express-backend-with-typescript-a-comprehensive-guide-b15fad5c803c
- For the final Node backend typescript config file, I used the tutorial: https://www.totaltypescript.com/tsconfig-cheat-sheet
- To allow for React/Node servers to start up by default on FireFox, you need to install the VSC extension "Debugger for FireFox" and configure the launch.json accordingly. **DOESNT WORK**
- I probably want to pull real news data from the internet to have half-related topics to play with, along with easy input data for the prompts, I suggest two free-enough APIs to think about: https://gnews.io/#pricing , https://newsdata.io/pricing -> I chose the second one
- We are using runware.ai for the image generation
- The Images in the website are(as of 7.5.25) exclusively in a 1.75:1 size.
- For each React component two rules must be kept with in regards to CSS organization:
    1. You must ask yourself whether the component should be an inline or block level element.
    2. An element should not have its own margin or padding unless: it is a basic html tag OR there is no component higher that is responsible for the final look.
